const { expect } = require('chai');
const { ethers } = require('hardhat');
const path = require('path');
const { pathToFileURL } = require('url');

const FALLBACK_FIXPARSER_LICENSE =
  'FIXParser_QjtkyzBGvFLS0tLS1CRUdJTiBQR1AgU0lHTkVEIE1FU1NBR0UtLS0tLQpIYXNoOiBTSEE1MTIKCjguMy4zfHN3cEBuZXRoZXJtaW5kLmlvfDE3ODgzOTM2MDAwMDB8ZnJlZQotLS0tLUJFR0lOIFBHUCBTSUdOQVRVUkUtLS0tLQoKd3JzRUFSWUtBRzBGZ21pNGZYZ0pFQ0p3M09mWVRzVEpSUlFBQUFBQUFCd0FJSE5oYkhSQWJtOTBZWFJwCmIyNXpMbTl3Wlc1d1ozQnFjeTV2Y21jaHZ2SS9ZQnR1QlB1R3ozKzY3Y3hWcitPeEZveE8xNzhLL1dtdApUSlAxeGhZaEJDVmdXQ2dKSU50bVgrZVpnaUp3M09mWVRzVEpBQUNHYWdEK0o3ZTN4ZzByc0d4TVYwZlEKMzlIM29EUjFlTitPb2xCR2VKM002djkxVGhBQS8yeEFlSUlhbi9VaS9qT2xyNVdRdGdGR1BpemYrbjdwCmpZMWllZEJVTkxnTgo9eGZNWgotLS0tLUVORCBQRw==';

const SAMPLE_FIX_MESSAGE = [
  '8=FIX.5.0',
  '35=D',
  '55=USTB-2030-11-15',
  '48=US000000AA11',
  '22=4',
  '167=TBOND',
  '200=20301115',
  '223=4.250',
  '15=USD',
  '453=[{448=ISSUER,452=1},{448=CUSTODIAN,452=24}]',
  '10=000'
].join('|');

async function buildDescriptorData() {
  if (!process.env.FIXPARSER_LICENSE_KEY) {
    process.env.FIXPARSER_LICENSE_KEY = FALLBACK_FIXPARSER_LICENSE;
  }

  const { parseFixDescriptor, buildCanonicalTree, encodeCanonicalCBOR,
          enumerateLeaves, computeRoot, generateProof
        } = await import("@fixdescriptorkit/ts-sdk");
  
  const tree = parseFixDescriptor(SAMPLE_FIX_MESSAGE);
  const canonical = buildCanonicalTree(tree);
  const cborBytes = encodeCanonicalCBOR(canonical);
  const leaves = enumerateLeaves(canonical);
  const root = computeRoot(leaves);

  const symbolPath = [55];
  const symbolLeaf = leaves.find(
    (leaf) => leaf.path.length === symbolPath.length && leaf.path.every((value, idx) => value === symbolPath[idx])
  );
  if (!symbolLeaf) {
    throw new Error('Generated descriptor is missing the Symbol (tag 55) leaf');
  }

  const proofRaw = generateProof(leaves, symbolPath);

  const toHex = (bytes) => `0x${Buffer.from(bytes).toString('hex')}`;

  return {
    descriptor: {
      fixMajor: 5,
      fixMinor: 0,
      dictHash: ethers.keccak256(ethers.toUtf8Bytes('fix.dictionary.demo.v1')),
      dictionaryContract: ethers.ZeroAddress,
      fixRoot: root,
      fixCBORPtr: ethers.ZeroAddress,
      fixCBORLen: cborBytes.length,
      fixURI: 'ipfs://fix/ustb-2030.json'
    },
    cborHex: toHex(cborBytes),
    leaves,
    proof: {
      pathCBOR: toHex(proofRaw.pathCBOR),
      valueBytes: toHex(proofRaw.valueBytes),
      proof: proofRaw.proof,
      directions: proofRaw.directions.map((isRight) => !isRight)
    },
    symbolValue: Buffer.from(proofRaw.valueBytes).toString('utf8'),
    canonical,
    cborBytes
  };
}

describe('FixDescriptorEngine (ts-sdk integration)', function () {
  let descriptorData;

  before(async function () {
    descriptorData = await buildDescriptorData();
  });

  async function deployEngineWithDescriptor() {
    const Engine = await ethers.getContractFactory('FixDescriptorEngineMock');
    const engine = await Engine.deploy();
    await engine.waitForDeployment();

    await expect(
      engine.setFixDescriptor(descriptorData.descriptor, descriptorData.cborHex)
    ).to.emit(engine, 'DescriptorSet');

    return engine;
  }

  it('stores canonical descriptor data derived from the ts-sdk', async function () {
    const engine = await deployEngineWithDescriptor();

    const stored = await engine.getFixDescriptor();

    expect(stored.fixMajor).to.equal(descriptorData.descriptor.fixMajor);
    expect(stored.fixMinor).to.equal(descriptorData.descriptor.fixMinor);
    expect(stored.fixCBORLen).to.equal(descriptorData.descriptor.fixCBORLen);
    expect(stored.fixRoot).to.equal(descriptorData.descriptor.fixRoot);

    expect(await engine.getFixRoot()).to.equal(descriptorData.descriptor.fixRoot);
    expect(await engine.isInitialized()).to.equal(true);

    const chunkHex = await engine.getFixCBORChunk(0, 16);
    expect(chunkHex).to.equal(`0x${Buffer.from(descriptorData.cborBytes.slice(0, 16)).toString('hex')}`);
  });

  it('verifies Merkle proofs generated by the ts-sdk', async function () {
    const engine = await deployEngineWithDescriptor();

    const { pathCBOR, valueBytes, proof, directions } = descriptorData.proof;

    expect(
      await engine.verifyField(pathCBOR, valueBytes, proof, directions)
    ).to.equal(true);

    expect(
      await engine.verifyField(pathCBOR, valueBytes, proof, directions.map((flag) => !flag))
    ).to.equal(false);

    const tamperedValue = ethers.hexlify(ethers.toUtf8Bytes('USTB-FAKE'));
    expect(
      await engine.verifyField(pathCBOR, tamperedValue, proof, directions)
    ).to.equal(false);
  });

  it('prevents descriptor re-initialisation', async function () {
    const engine = await deployEngineWithDescriptor();

    await expect(
      engine.setFixDescriptor(descriptorData.descriptor, descriptorData.cborHex)
    ).to.be.revertedWithCustomError(engine, 'DescriptorAlreadyInitialized');

    const updatedDescriptor = {
      ...descriptorData.descriptor,
      fixRoot: ethers.keccak256(ethers.toUtf8Bytes('new-root'))
    };

    await expect(
      engine.updateFixDescriptor(updatedDescriptor, descriptorData.cborHex)
    ).to.emit(engine, 'DescriptorUpdated').withArgs(
      updatedDescriptor.fixRoot,
      updatedDescriptor.fixMajor,
      updatedDescriptor.fixMinor
    );
  });

  it('provides human-readable output with contextual data', async function () {
    const engine = await deployEngineWithDescriptor();
    const human = await engine.getHumanReadableDescriptor();

    expect(human).to.include('FIX 5.0');
    expect(human).to.include(descriptorData.descriptor.fixRoot.slice(2, 10));
  });
});

